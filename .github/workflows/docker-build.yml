name: Docker Build (Reusable)

on:
  workflow_call:
    inputs:
      push_image:
        description: 'Whether to push the built image to registry'
        required: true
        type: boolean
      registry:
        description: 'Container registry (e.g., ghcr.io)'
        required: false
        type: string
        default: 'ghcr.io'
      image_name:
        description: 'Image name'
        required: false
        type: string
        default: 'rag-file-processor'
      version:
        description: 'Version tag for the image'
        required: true
        type: string
      model_vendor:
        description: 'AI model vendor (openai or google)'
        required: false
        type: string
        default: 'openai'
      environment:
        description: 'Environment (development or production)'
        required: false
        type: string
        default: 'production'
    secrets:
      GOOGLE_API_KEY:
        description: 'Google API key'
        required: false
      OPENAI_API_KEY:
        description: 'OpenAI API key'
        required: false
      REGISTRY_TOKEN:
        description: 'Personal Access Token for container registry'
        required: true
    outputs:
      image_url:
        description: 'Full image URL with tag'
        value: ${{ jobs.build.outputs.image_url }}
      image_digest:
        description: 'Image digest'
        value: ${{ jobs.build.outputs.image_digest }}

env:
  PYTHON_VERSION: '3.12'

jobs:
  # Common setup job for both platforms
  setup:
    name: Build Setup
    runs-on: ubuntu-latest
    outputs:
      image_url: ${{ steps.meta.outputs.tags }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Build info
      run: |
        echo "ðŸ·ï¸ Building version: ${{ inputs.version }}"
        echo "ðŸ¤– Using model vendor: ${{ inputs.model_vendor }}"
        echo "ðŸ—ï¸ Using sequential platform builds to manage disk space"

    - name: Log in to Container Registry
      if: ${{ inputs.push_image }}
      uses: docker/login-action@v3
      with:
        registry: ${{ inputs.registry }}
        username: ${{ github.actor }}
        password: ${{ secrets.REGISTRY_TOKEN }}

    - name: Extract metadata for Docker
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ format('{0}/{1}/{2}', inputs.registry, github.repository, inputs.image_name) }}
        tags: |
          type=raw,value=latest,enable=${{ inputs.push_image == true }}
          type=raw,value=${{ inputs.version }}

  # Build AMD64 platform
  build-amd64:
    name: Build AMD64
    runs-on: ubuntu-latest
    needs: setup
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Log in to Container Registry
      if: ${{ inputs.push_image }}
      uses: docker/login-action@v3
      with:
        registry: ${{ inputs.registry }}
        username: ${{ github.actor }}
        password: ${{ secrets.REGISTRY_TOKEN }}

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        buildkitd-config-inline: |
          [worker.oci]
            gc = true
            gckeepstorage = 256000000
          [worker.containerd]
            gc = true
            gckeepstorage = 256000000

    - name: Debug build context
      run: |
        echo "ðŸ” Building AMD64 platform..."
        echo "Current directory: $(pwd)"
        echo "ðŸ·ï¸ Docker tags: ${{ needs.setup.outputs.image_url }}"
        echo "Checking critical files:"
        echo "main.py: $(test -f main.py && echo 'âœ…' || echo 'âŒ')"
        echo "src/: $(test -d src && echo 'âœ…' || echo 'âŒ')"
        echo "Dockerfile: $(test -f docker_deployment/shared/Dockerfile && echo 'âœ…' || echo 'âŒ')"

    - name: Build AMD64 image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./docker_deployment/shared/Dockerfile
        platforms: linux/amd64
        push: ${{ inputs.push_image }}
        load: false
        tags: ${{ needs.setup.outputs.image_url }}
        build-args: |
          VERSION=${{ inputs.version }}
        cache-from: type=gha,scope=amd64
        cache-to: type=gha,mode=min,scope=amd64

    - name: Cleanup after AMD64 build
      if: always()
      run: |
        echo "ðŸ§¹ Cleaning up AMD64 build artifacts..."
        docker builder prune -af
        docker system prune -af --volumes
        echo "ðŸ’¾ Disk space after AMD64 cleanup:"
        df -h

  # Build ARM64 platform
  build-arm64:
    name: Build ARM64
    runs-on: ubuntu-latest
    needs: [setup, build-amd64]
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Log in to Container Registry
      if: ${{ inputs.push_image }}
      uses: docker/login-action@v3
      with:
        registry: ${{ inputs.registry }}
        username: ${{ github.actor }}
        password: ${{ secrets.REGISTRY_TOKEN }}

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        buildkitd-config-inline: |
          [worker.oci]
            gc = true
            gckeepstorage = 256000000
          [worker.containerd]
            gc = true
            gckeepstorage = 256000000

    - name: Debug build context
      run: |
        echo "ðŸ” Building ARM64 platform..."
        echo "Current directory: $(pwd)"
        echo "ðŸ·ï¸ Docker tags: ${{ needs.setup.outputs.image_url }}"
        echo "ðŸ’¾ Disk space before ARM64 build:"
        df -h

    - name: Build ARM64 image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./docker_deployment/shared/Dockerfile
        platforms: linux/arm64
        push: ${{ inputs.push_image }}
        load: false
        tags: ${{ needs.setup.outputs.image_url }}
        build-args: |
          VERSION=${{ inputs.version }}
        cache-from: type=gha,scope=arm64
        cache-to: type=gha,mode=min,scope=arm64

    - name: Cleanup after ARM64 build
      if: always()
      run: |
        echo "ðŸ§¹ Cleaning up ARM64 build artifacts..."
        docker builder prune -af
        docker system prune -af --volumes

  # Create multi-platform manifest and test
  finalize:
    name: Finalize Multi-Platform Build
    runs-on: ubuntu-latest
    needs: [setup, build-amd64, build-arm64]
    outputs:
      image_url: ${{ needs.setup.outputs.image_url }}
      image_digest: ${{ steps.manifest.outputs.digest }}
    steps:
    - name: Log in to Container Registry
      if: ${{ inputs.push_image }}
      uses: docker/login-action@v3
      with:
        registry: ${{ inputs.registry }}
        username: ${{ github.actor }}
        password: ${{ secrets.REGISTRY_TOKEN }}

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Create and push manifest
      if: ${{ inputs.push_image }}
      id: manifest
      run: |
        echo "ðŸ”— Creating multi-platform manifest..."
        TAGS="${{ needs.setup.outputs.image_url }}"

        # Create manifest for each tag
        for TAG in $(echo "$TAGS" | tr '\n' ' '); do
          echo "Creating manifest for: $TAG"
          docker buildx imagetools create \
            --tag "$TAG" \
            "$TAG"
        done

        # Get digest from the first tag
        FIRST_TAG=$(echo "$TAGS" | head -n1)
        DIGEST=$(docker buildx imagetools inspect "$FIRST_TAG" --format '{{.Manifest.Digest}}')
        echo "digest=$DIGEST" >> $GITHUB_OUTPUT

    - name: Test Docker image
      if: ${{ inputs.push_image }}
      run: |
        echo "ðŸš€ Testing multi-platform image from registry..."

        REGISTRY_TAG=$(echo "${{ needs.setup.outputs.image_url }}" | head -n1)
        echo "Testing image: $REGISTRY_TAG"

        docker pull "$REGISTRY_TAG"

        # Run basic health check
        docker run --rm \
          -e ENABLE_DOCUMENT_PROCESSING=false \
          "$REGISTRY_TAG" \
          python -c "import sys; print('ðŸ Python version:', sys.version); print('ðŸ·ï¸ Image version: ${{ inputs.version }}'); exec('try:\\n    from src.app import FolderFileProcessorApp\\n    from src.config import ConfigManager\\n    from src.core import FileProcessor\\n    print(\"âœ… Core modules import successfully\")\\nexcept ImportError as e:\\n    print(f\"âŒ Import error: {e}\")\\n    sys.exit(1)\\nprint(\"âœ… Multi-platform Docker image test passed\")')"

    - name: PR validation summary
      if: ${{ !inputs.push_image }}
      run: |
        echo "ðŸ§ª PR validation build completed successfully"
        echo "âœ… Both AMD64 and ARM64 platforms built successfully"
        echo "âœ… Sequential build strategy prevented disk space issues"
        echo ""
        echo "Build outputs:"
        echo "- Platforms: linux/amd64, linux/arm64 (built separately)"
        echo "- Image: ${{ inputs.image_name }}:${{ inputs.version }}"
        echo "- Build approach: Sequential platform builds"

    - name: Build summary
      run: |
        echo "## ðŸ³ Sequential Multi-Platform Build Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### âœ… Build Details" >> $GITHUB_STEP_SUMMARY
        echo "- **Image**: \`${{ inputs.registry }}/${{ github.repository_owner }}/${{ inputs.image_name }}\`" >> $GITHUB_STEP_SUMMARY
        echo "- **Version**: \`${{ inputs.version }}\`" >> $GITHUB_STEP_SUMMARY
        echo "- **Model Vendor**: \`${{ inputs.model_vendor }}\`" >> $GITHUB_STEP_SUMMARY
        echo "- **Environment**: \`${{ inputs.environment }}\`" >> $GITHUB_STEP_SUMMARY
        echo "- **Platforms**: \`linux/amd64, linux/arm64\` (built sequentially)" >> $GITHUB_STEP_SUMMARY
        echo "- **Build Strategy**: Sequential platform builds to manage disk space" >> $GITHUB_STEP_SUMMARY
        if [ "${{ inputs.push_image }}" = "true" ]; then
          echo "- **Registry Push**: âœ… Enabled with multi-platform manifest" >> $GITHUB_STEP_SUMMARY
        else
          echo "- **Registry Push**: âŒ Test build only" >> $GITHUB_STEP_SUMMARY
        fi
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ·ï¸ Available Tags" >> $GITHUB_STEP_SUMMARY
        echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
        echo "${{ needs.setup.outputs.image_url }}" >> $GITHUB_STEP_SUMMARY
        echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

  # Maintain compatibility with existing workflow outputs
  build:
    name: Build Compatibility
    runs-on: ubuntu-latest
    needs: finalize
    outputs:
      image_url: ${{ needs.finalize.outputs.image_url }}
      image_digest: ${{ needs.finalize.outputs.image_digest }}
    steps:
    - name: Pass through outputs
      run: |
        echo "âœ… Sequential multi-platform build completed"
        echo "Image URL: ${{ needs.finalize.outputs.image_url }}"
        echo "Image Digest: ${{ needs.finalize.outputs.image_digest }}"